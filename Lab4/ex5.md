# Exercise 5
 #### 1. These approaches are designed to deal with different types of measurement noise. Think about what happens when we try to time a program, and which types of issues may result in an incorrect measurement. Reflect on how the two approaches (timeit and repeat) attempt to address these issues. Discuss when it is appropriate to use one or the other.
When timing a program or even certain pieces of code, there are a multitude of external factors that can affect the execution time which are not related to the implementation itself. Python's garbage collection, computer specs, differences in compilers, etc. To mitigate these external factors, both timeit() and repeat() disable garbage collection to avoid overhead from affecting the measured execution time, and repeat snippet execution (one million times default) such that we get the most statistically relevant measurement of code execution time. In general, timeit() is appropriate when we need only a quick, single measurement; repeat() when you want multiple measurements to analyze the variability of execution time.

#### 2. Typically, the output of timeit is post-processed to compute some sort of aggregate statistics. Letâ€™s only consider three: average, min, and max. Which one is the appropriate statistic to apply to the output of timeit.timeit()? What is the appropriate statistics to apply to the output of timeit.repeat()? Discuss why.
For timeit.timeit(), average execution time is the more appropriate statistic to apply to its output, while the output of timeit.repeat() is more appropriately applied to the minimum and maximum statistics. The average statistic represents a balanced view of overall performance, helping us understand the typical time the code takes to execute. As such, timeit() is appropriate here as it executes the code snippet multiple times already. Repititon of execution as given by the repeat() function is more useful for min/max statistics as you would typically want a list of average execution times when using a specific value (for best case/worst case) to account for variations/outliers more rigorously than timeit() does. 